\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}

\title{Database Design}
\author{Joshua Harrison}
\date{\today}

\begin{document}
\maketitle

\section{Relational Design}

\subsection{Relationl schema design}
This section will discuss some of the notworthy descisions taken in the design of the relational schema for the given problem domain.
The full SQL for the relational schema can be seen in \emph{appendix 1.1}. Note: \emph{PostgreSQL 9.6} is used for all DML and DDL defined in this document. The online SQL compiler https://rextester.com was used to validate the schema and its constraints.

\subsubsection{Types}
The schema defines two custom enum types, namely  `ISO3166\_ALPHA2' (based on the ISO3166 standard), and `AQUISITION\_STATUS'. It is worth noting that `ISO3166\_ALPHA2' is loaded with a subset of the full standard as this is fit for the purpose of our data model.

The AQUISITION\_STATUS status enum is implement by the \emph{status} column in the \emp{acquisition} table, and the ISO3166\_ALPHA2 enum is implemented diretly by the \emp{country} table as well as all tables which contain a foriegn key to this (\emph{company}, \emph{founder}).

The use of Enums is advantegous as it provides a means of implict santisation to the tables that implement these types. For example it means an \emph{acquisition} instance could never be created with an undeseriable status (i.e a status outside the domain of strings defined by the enum). The same is true of the ISO3166\_ALPHA2 implemention, through it we can be assured the quality of the country code in the database is acurate. Considering Date's  oberservation [REF - Date] that a table can be thought of as a predicate for which each row is a true proposition, custom data types enable use to constrain the domain of the predicate to only relevant values. For example, the ISO3166\_ALPHA2 implemented in this model it would be impossible to enter a country with the values `Norway', `NO'.

It should be noted that the tuple (`Norway', `CN') would be a valid entry into the country table. We can verify that this record is false as per the ISO3166 standard [REF ISO3166], however there is nothing wrong with it from the data storage level. Therefore although implementing the custom type has helped with intrity, it has not guarenteed the quality of the data, or put another way it, is possible for our schema to record false propositions. A further improvement would therefore be to drop the country table altogether extend the custom type to include the country name and code.

\subsubsection{Relational Schema Design}
For the given problem the following schema has been defined.

\begin{tabular}{l|c|l}
Name&PK&Description\\\hline
Company&ID&A store for all companes\\
\end{tabular}

\subsection{Normalisation}
Is this design in BCNF? Before we give an answer to this, let us first list out non-trivial functional dependencies for the schema.

\subsection{Functional Dependencies}
\subsubsection{Company}

id \Rightarrow{\{name, founded, country\_code, parent\_company\_id\}} \\
name \Rightarrow{founder} \\
name \Rightarrow{parent\_code\_id} \\
name \not \Rightarrow{country\_code} \textsuperscript{*} \\

\\ \textsuperscript{*} N.b This pair is not a functional dependency due to the unique constraint that is inplace between these two columns. Had this additional constraint not been implamented then a functional dependency could be possible here. To ellobarate, it is impossible to have to rows in which these values are dependent due to this unique constraint. An insert of `two companies of the same name in the same country, therefore these rows are not functionally dependent.

\subsubsection{Founder}
name \Rightarrow{dob} \\
name \Rightarrow{country\_of\_origin}

\subsubsection{Acquisition}
\{parent\_company\_id, child\_company\_id\} \Rightarrow{\{announced\_date, completion\_date}\} \\
 \{parent\_company\_id, child\_company\_id\} \not \Rightarrow status \textsuperscript{*} \\

\textsuperscript{*}N.b. Depending on the implemention of the data model, this functional dependency may or may not be present. For example, given a scenario in which \emph{company A} makes a failed attempt to acquire \emph{company B}, there are two potenial ways to record this data. 1) To create a new row for the second attempted acquisition (i.e. a record exists for both the failed and successful acquisition), or 2) the original record is updated (i.e only one record exists which is updated). The first implemention has a practical advantages in that it enables us to keep a historised account of all acquisition attempts between any companies. In this implemenation this functional dependency does not exist (as expressed above). Conversely, the second \textit{non-historised} implemenation only stores half the story - specify, which ever acquisition was announced most recently.

\begin{tabular}{l|c|l|r}
parent company&chid company&status&date\\\hline
Company A&Company B&Failed\\b\\
Company A&Company B&Failed\\y\\
\end{tabular}


\end{document}
